// adaptive_alpha.hpp  -- generated by adaptive_labeler.py
// Drop into ~/HFT/engine/ alongside OrderBook.hpp

#pragma once
#include <deque>
#include <cmath>

// Sampled ATR: accumulates mid-prices on a fixed time grid (sample_interval_s),
// computes rolling ATR over atr_window_s of those samples.
// This avoids measuring bid-ask bounce noise between consecutive quotes.
class AdaptiveAlpha {
public:
    AdaptiveAlpha(double sample_interval_s = 0.010,
                  double atr_window_s      = 60.0,
                  double multiplier        = 2.0)
        : sample_s_(sample_interval_s),
          win_s_(atr_window_s),
          mult_(multiplier) {}

    void update(double timestamp, double best_bid, double best_ask) {
        current_mid_ = (best_bid + best_ask) * 0.5;
        current_ts_  = timestamp;

        // Only sample at fixed intervals
        if (last_sample_ts_ < 0.0 || (timestamp - last_sample_ts_) >= sample_s_) {
            if (last_sample_mid_ > 0.0) {
                double tr = std::fabs(current_mid_ - last_sample_mid_);
                buf_.push_back({timestamp, tr});
                sum_ += tr;
                // Evict samples outside the window
                while (!buf_.empty() &&
                       (timestamp - buf_.front().ts) > win_s_) {
                    sum_ -= buf_.front().tr;
                    buf_.pop_front();
                }
            }
            last_sample_ts_  = timestamp;
            last_sample_mid_ = current_mid_;
        }
    }

    // Returns normalized alpha. -1.0 = insufficient history.
    double alpha() const {
        if (buf_.empty() || current_mid_ <= 0.0) return -1.0;
        double atr = sum_ / (double)buf_.size();
        return mult_ * atr / current_mid_;
    }

    // 0=DOWN 1=FLAT 2=UP -1=not ready
    int label(double future_mid) const {
        double a = alpha();
        if (a <= 0.0) return -1;
        double pct = (future_mid - current_mid_) / current_mid_;
        if (pct < -a) return 0;
        if (pct >  a) return 2;
        return 1;
    }

    bool   ready()        const { return !buf_.empty(); }
    double current_mid()  const { return current_mid_; }

private:
    struct Entry { double ts; double tr; };
    double             sample_s_, win_s_, mult_;
    double             current_mid_    = 0.0;
    double             current_ts_     = 0.0;
    double             last_sample_ts_ = -1.0;
    double             last_sample_mid_= 0.0;
    double             sum_            = 0.0;
    std::deque<Entry>  buf_;
};